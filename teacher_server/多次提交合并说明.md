# 多次提交合并功能说明

## 功能概述

支持学生分多次提交数据（每次做完一个题目就提交），所有提交会合并到同一条记录中，避免在教师端看到多条重复数据。

## 工作原理

### 1. 首次提交（创建新记录）

**客户端请求（不提供 submission_id）：**
```json
{
  "studentInfo": {
    "school": "测试学校",
    "grade": "高一",
    "classNumber": "1",
    "date": "2024-12-28",
    "memberCount": 2,
    "memberNames": ["张三", "李四"]
  },
  "task1": {
    "teaName": "龙井",
    ...
  }
}
```

**服务器响应：**
```json
{
  "success": true,
  "message": "数据保存成功",
  "submissionId": "测试学校_高一_1_20241228_a1b2c3d4_20241228_120000_123456"
}
```

**客户端需要保存 `submissionId` 供后续提交使用。**

### 2. 后续提交（更新现有记录）

**客户端请求（提供 submission_id）：**
```json
{
  "submission_id": "测试学校_高一_1_20241228_a1b2c3d4_20241228_120000_123456",
  "studentInfo": {
    "school": "测试学校",
    "grade": "高一",
    "classNumber": "1",
    "date": "2024-12-28",
    "memberCount": 2,
    "memberNames": ["张三", "李四"]
  },
  "task2": {
    "teaName": "铁观音",
    ...
  }
}
```

**服务器响应：**
```json
{
  "success": true,
  "message": "数据更新成功",
  "submissionId": "测试学校_高一_1_20241228_a1b2c3d4_20241228_120000_123456"
}
```

## 安全验证机制

为了防止不同学生组误用相同的 `submission_id`，服务器会进行严格验证：

### 验证项

1. **成员信息匹配**
   - 提交的成员列表必须与现有记录的成员列表完全一致
   - 成员顺序不影响匹配（会自动排序比较）

2. **活动日期匹配**
   - 提交的活动日期必须与现有记录的活动日期一致

3. **学校/年级/班级匹配**
   - 学校、年级、班级信息必须完全匹配

4. **时间限制**
   - 只能更新30天内的记录
   - 超过30天的记录不允许更新，需要创建新提交

### 验证失败示例

如果验证失败，服务器会返回详细的错误信息：

```json
{
  "success": false,
  "message": "成员信息不匹配。现有成员：['张三', '李四']，提交成员：['王五', '赵六']。请检查是否为同一组学生，或创建新提交。"
}
```

## submission_id 生成规则

`submission_id` 格式：`学校_年级_班级_日期_成员哈希_时间戳`

- **学校/年级/班级**：基本信息
- **日期**：活动日期（YYYYMMDD格式）
- **成员哈希**：成员姓名列表的MD5哈希值前8位（确保同一组学生生成相同的哈希）
- **时间戳**：精确到微秒（YYYYMMDD_HHMMSS_微秒）

### 示例

```
测试学校_高一_1_20241228_a1b2c3d4_20241228_120000_123456
```

## 客户端实现建议

### 1. 保存 submission_id

首次提交成功后，将返回的 `submissionId` 保存到本地存储：

```kotlin
// 保存 submission_id
val prefs = context.getSharedPreferences("Submission", Context.MODE_PRIVATE)
prefs.edit().putString("submission_id", submissionId).apply()
```

### 2. 后续提交携带 submission_id

每次提交时，检查是否有保存的 `submission_id`：

```kotlin
val submissionId = prefs.getString("submission_id", null)
if (submissionId != null) {
    json.put("submission_id", submissionId)
}
```

### 3. 清空数据时清除 submission_id

**重要**：当老师清空APP内容时，必须同时清除 `submission_id`：

```kotlin
fun clearAllData() {
    // 清空所有数据
    val prefs = context.getSharedPreferences("TeaCultureApp", Context.MODE_PRIVATE)
    prefs.edit().clear().apply()
    
    // 同时清除 submission_id
    val submissionPrefs = context.getSharedPreferences("Submission", Context.MODE_PRIVATE)
    submissionPrefs.edit().remove("submission_id").apply()
}
```

**如果不清除，下一班学生可能会误用上一班学生的 submission_id！**

### 4. 处理验证失败

如果服务器返回验证失败错误，客户端应该：

1. 清除本地保存的 `submission_id`
2. 提示用户创建新提交
3. 或者自动重新提交（不提供 submission_id）

```kotlin
if (!response.success && response.message.contains("不匹配")) {
    // 清除错误的 submission_id
    prefs.edit().remove("submission_id").apply()
    // 提示用户或自动重新提交
}
```

## 常见问题

### Q1: 如果客户端丢失了 submission_id 怎么办？

**A:** 可以创建新提交（不提供 submission_id），服务器会创建新记录。但这样会导致教师端看到多条记录。

### Q2: 可以更新部分任务数据吗？

**A:** 可以。只需要在请求中包含要更新的任务数据即可。例如，只更新 task2：

```json
{
  "submission_id": "...",
  "studentInfo": { ... },
  "task2": { ... }
}
```

### Q3: 更新时会覆盖旧数据吗？

**A:** 是的。更新时会：
- 覆盖任务数据（task1, task2, thinking1, thinking2, creative）
- 删除旧照片，保存新照片
- 更新提交时间

### Q4: 如果同一组学生在不同设备上提交怎么办？

**A:** 每台设备都会创建新记录（因为没有共享 submission_id）。建议：
- 使用同一台设备完成所有提交
- 或者首次提交后，手动记录 submission_id 并在其他设备上使用

### Q5: submission_id 太长怎么办？

**A:** submission_id 虽然较长，但确保了唯一性和安全性。客户端只需要保存和传递即可，不需要理解其结构。

## 技术细节

### 数据库影响

- 更新记录时，会更新 `submit_time` 和 `updated_at` 字段
- 任务数据会覆盖更新
- 照片会删除旧的后保存新的

### 性能考虑

- 验证逻辑在数据库层面进行，性能良好
- 成员信息哈希计算很快（MD5）
- 照片删除和保存是顺序操作，不会阻塞

### 错误处理

所有验证失败都会返回详细的错误信息，帮助客户端和用户理解问题。

## 总结

这个功能的核心是：
1. **首次提交** → 创建新记录，返回 `submission_id`
2. **后续提交** → 携带 `submission_id`，验证后更新记录
3. **严格验证** → 确保只有同一组学生才能更新记录
4. **客户端配合** → 正确保存和清除 `submission_id`

只要客户端正确实现，就能完美支持分次提交，同时避免数据混乱。

